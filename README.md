
## Домашнее задание 13. Дерево поиска на Prolog
1. Реализуйте ассоциативный массив (map) на основе деревьев поиска. Для решения можно реализовать любое дерево поиска логарифмической высоты.
2. Разработайте правила: 
     * map_build(ListMap, TreeMap), строящее дерево из упорядоченного списка пар ключ-значение (O(n));
     * map_get(TreeMap, Key, Value), проверяющее, что массив содержит заданную пару ключ-значение (O(log n)).

Модификации
 * *Базовая*
    * Код должен находиться в файле `prolog-solutions/tree-map.pl`.
    * [Исходный код тестов](prolog/prtest/tree/PrologTreeTest.java)
        * Запускать c аргументом `easy` или `hard`

 * *KeysValues* 
    * Добавьте правила:
        * `map_Keys(Map, Keys)`, возвращающее ключи в порядке возрастания;
        * `map_Values(Map, Values)`, возвращающее значения в порядке возрастания ключей.


## Домашнее задание 12. Простые числа на Prolog

1. Разработайте правила:

   * prime(N), проверяющее, что N – простое число.
   * composite(N), проверяющее, что N – составное число.
   * prime_divisors(N, Divisors), проверяющее, что список Divisors содержит все простые делители числа N, упорядоченные по возрастанию. Если N делится на простое число P несколько раз, то Divisors должен содержать соответствующее число копий P.
2. Вариант N <= 1000.
3. Вы можете рассчитывать, на то, что до первого запроса будет выполнено правило init(MAX_N).

Модификации
 * *Базовая*
    * Код должен находиться в файле `prolog-solutions/primes.pl`.
    * [Исходный код тестов](prolog/prtest/primes/PrologPrimesTest.java)
        * Запускать c аргументом `easy`, `hard` или `bonus`

 * *Power* 
    * Добавьте правило `power_divisors(N, I, D)`, возвращающее делители Nⁱ:
      `power_divisors(6, 2, [2, 2, 3, 3])`.
    * [Исходный код тестов](prolog/prtest/primes/PrologPowerTest.java)
 
Для запуска тестов можно использовать скрипты
[TestProlog.cmd](prolog/TestProlog.cmd) и [TestProlog.sh](prolog/TestProlog.sh)
 * Репозиторий должен быть скачан целиком.
 * Скрипты должны находиться в каталоге `prolog`
    (их нельзя перемещать, но можно вызывать из других каталогов).
 * Полное имя класса теста указывается в качестве первого аргумента командной строки,
    например, `prtest.primes.PrologPrimesTest`.
 * Тестируемое решение должно находиться в текущем каталоге.


## Исходный код к лекциям по Prolog

Запуск Prolog
 * [Windows](prolog/RunProlog.cmd)
 * [*nix](prolog/RunProlog.sh)

Лекция 1. Факты, правила и вычисления
 * [Учебный план](prolog/examples/1_1_plan.pl)
 * [Вычисления](prolog/examples/1_2_calc.pl)
 * [Списки](prolog/examples/1_3_lists.pl)
 * [Правила высшего порядка](prolog/examples/1_4_high-order.pl)

Лекция 2. Задачи, унификация и объекты
 * [Задача о расстановке ферзей](prolog/examples/2_1_queens.pl)
 * [Задача Эйнштейна](prolog/examples/2_2_einstein.pl)
 * [Арифметические выражения](prolog/examples/2_3_expressions.pl)

Лекция 3. Преобразование в строку и разбор
 * [Преобразование через термы](prolog/examples/3_1_terms.pl)
 * [Преобразование через списки](prolog/examples/3_2_chars.pl)
 * [Грамматики](prolog/examples/3_3_grammar.pl)


## Домашнее задание 11. Комбинаторные парсеры
1. Реализуйте функцию (parseObjectSuffix "expression"), разбирающую выражения, записанные в суффиксной форме, и функцию `toStringSuffix`, возвращающую строковое представление выражения в этой форме. Например,
`(toStringSuffix (parseObjectSuffix "( ( 2 x * ) 3 - )"))`
должно возвращать `((2 x *) 3 -)`.
2. Функции разбора должны базироваться на библиотеке комбинаторов, разработанной на лекции.

Модификации
 * *Базовая*
    * Код должен находиться в файле `clojure-solutions/expression.clj`.
    * [Исходный код тестов](clojure/cljtest/parsing/ParserTest.java)
        * Запускать c указанием модификации и сложности (`easy` или `hard`).

 * *Boolean*. Сделать модификацию *Variables* и дополнительно реализовать поддержку:
    * Булевских операций
        * Аргументы: число больше 0 → `true`, иначе → `false`
        * Результат: `true` → 1, `false` → 0
        * `And` (`&&`) – и: `5 & -6` равно 0
        * `Or`  (`||`) - или: `5 & -6` равно 1
        * `Xor` (`^^`) - исключающее или: `5 ^ -6` равно 1
        * операции по увеличению приоритета: `^^`, `||`, `&&`, операции базовой модификации
 

## Домашнее задание 10. Объектные выражения на Clojure

1.  Разработайте конструкторы `Constant`, `Variable`, `Add`, `Subtract`, `Multiply` и `Divide` для представления выражений с одной переменной.
    1.  Пример описания выражения `2x-3`:
        ```
        (def expr
          (Subtract
            (Multiply
              (Constant 2)
              (Variable "x"))
            (Const 3)))
        ```                    
        
    2.  Функция `(evaluate expression vars)` должна производить вычисление выражения `expression` для значений переменных, заданных отображением `vars`. Например, `(evaluate expr {"x" 2})` должно быть равно 1.
    3.  Функция `(toString expression)` должна выдавать запись выражения в стандартной для Clojure форме.
    4.  Функция `(parseObject "expression")` должна разбирать выражения, записанные в стандартной для Clojure форме. Например,
        
        `(parseObject "(- (\* 2 x) 3)")`
        
        должно быть эквивалентно `expr`.
    5.  Функция `(diff expression "variable")` должена возвращать выражение, представляющее производную исходного выражения по заданой пермененной. Например, `(diff expression "x")` должен возвращать выражение, эквивалентное `(Constant 2)`, при этом выражения `(Subtract (Const 2) (Const 0))` и
        ```
        (Subtract
          (Add
            (Multiply (Const 0) (Variable "x"))
            (Multiply (Const 2) (Const 1)))
          (Const 0))
         ```                   
        так же будут считаться правильным ответом.
  2. При выполнение задания можно использовать любой способ преставления объектов.

Модификации
 * *Base*
    * Код должен находиться в файле `clojure-solutions/expression.clj`.
    * [Исходный код тестов](clojure/cljtest/object/ObjectTest.java)
        * Запускать c указанием модификации и сложности (`easy` или `hard`).
 
 * *SinhCosh*. Дополнительно реализовать поддержку:
    * унарных операций:
        * `Sinh` (`sinh`) – гиперболический синус, `(sinh 3)` немного больше 10;
        * `Cosh` (`cosh`) – гиперболический косинус, `(cosh 3)` немного меньше 10.
 


## Домашнее задание 9. Функциональные выражения на Clojure
1.  Разработайте функции `constant`, `variable`, `add`, `subtract`, `multiply` и `divide` для представления арифметических выражений.
    1.  Пример описания выражения `2x-3`:
        ```
        (def expr
          (subtract
            (multiply
              (constant 2)
              (variable "x"))
            (constant 3)))
        ```                    
        
    2.  Выражение должно быть функцией, возвращающей значение выражение при подстановке элементов, заданных отображением. Например, `(expr {"x" 2})` должно быть равно 1.
2.  Разработайте разборщик выражений, читающий выражения в стандартной для Clojure форме. Например,
    
    `(parseFunction "(- (\* 2 x) 3)")`
    
    должно быть эквивалентно `expr`.

3.  При выполнение задания следует обратить внимание на:
    *   Выделение общего кода для операций.
    
Модификации
 * *Base*
    * Код должен находиться в файле `clojure-solutions/expression.clj`.
    * [Исходный код тестов](clojure/cljtest/functional/FunctionalTest.java)
        * Запускать c указанием модификации и сложности (`easy` или `hard`).
 
 * *SinhCosh*. Дополнительно реализовать поддержку:
    * унарных операций:
        * `sinh` – гиперболический синус, `(sinh 3)` немного больше 10;
        * `cosh` – гиперболический косинус, `(cosh 3)` немного меньше 10.


## Домашнее задание 8. Линейная алгебра на Clojure

1.  Разработайте функции для работы с объектами линейной алгебры, которые представляются следующим образом:
    *   скаляры – числа
    *   векторы – векторы чисел;
    *   матрицы – векторы векторов чисел.
2.  Функции над векторами:
    *   `v+`/`v-`/`v*` – покоординатное сложение/вычитание/умножение;
    *   `scalar`/`vect` – скалярное/векторное произведение;
    *   `v*s` – умножение на скаляр.
3.  Функции над матрицами:
    *   `m+`/`m-`/`m*` – поэлементное сложение/вычитание/умножение;
    *   `m*s` – умножение на скаляр;
    *   `m*v` – умножение на вектор;
    *   `m*m` – матричное умножение;
    *   `transpose` – траспонирование;

4.  Все функции должны поддерживать произвольное число аргументов. Например `(v+ [1 2] [3 4] [5 6])` должно быть равно `[9 12]`.
5.  При выполнение задания следует обратить внимание на:
    *   Применение функций высшего порядка.
    *   Выделение общего кода для операций.


Модификации
 * *Базовая*
    * Код должен находиться в файле `clojure-solutions/linear.clj`.
    * [Исходный код тестов](clojure/cljtest/linear/LinearTest.java)
        * Запускать c аргументом `easy` или `hard`
 
 * *Tensor*
    * Назовем _тензором_ многомерную прямоугольную таблицу чисел.
    * Добавьте операции поэлементного сложения (`t+`),
        вычитания (`t-`) и умножения (`t*`) тензоров.
        Например, `(t+ [[1 2] [3 4]] [[5 6] [7 8]])` должно быть равно `[[6 8] [10 12]]`.
    * [Исходный код тестов](clojure/cljtest/linear/TensorTest.java)


Для запуска тестов можно использовать скрипты
[TestClojure.cmd](clojure/TestClojure.cmd) и [TestClojure.sh](clojure/TestClojure.sh)
 * Репозиторий должен быть скачан целиком.
 * Скрипты должны находиться в каталоге `clojure`
    (их нельзя перемещать, но можно вызывать из других каталогов).
 * Полное имя класса теста указывается в качестве аргумента командной строки,
    например, `cljtest.linear.LinearTest`.
 * Тестируемое решение должно находиться в текущем каталоге.


## Исходный код к лекциям по Clojure

Запуск Clojure
 * Консоль: [Windows](clojure/RunClojure.cmd), [*nix](clojure/RunClojure.sh)
    * Интерактивный: `RunClojure`
    * С выражением: `RunClojure --eval "<выражение>"`
    * Скрипт: `RunClojure <файл скрипта>`
    * Справка: `RunClojure --help`
 * IDE
    * IntelliJ Idea: [плагин Cursive](https://cursive-ide.com/userguide/)
    * Eclipse: [плагин Counterclockwise](https://doc.ccw-ide.org/documentation.html)

[Скрипт со всеми примерами](clojure/examples.clj)

Лекция 1. Функции
 * [Введение](clojure/examples/1_1_intro.clj)
 * [Функции](clojure/examples/1_2_functions.clj)
 * [Списки](clojure/examples/1_3_lists.clj)
 * [Вектора](clojure/examples/1_4_vectors.clj)
 * [Функции высшего порядка](clojure/examples/1_5_functions-2.clj)

Лекция 2. Внешний мир
 * [Ввод-вывод](clojure/examples/2_1_io.clj)
 * [Разбор и гомоиконность](clojure/examples/2_2_read.clj)
 * [Порядки вычислений](clojure/examples/2_3_evaluation-orders.clj)
 * [Потоки](clojure/examples/2_4_streams.clj)
 * [Отображения и множества](clojure/examples/2_5_maps.clj)

Лекция 3. Объекты
 * [Прототипное наследование](clojure/examples/3_1_js-objects.clj)
 * [Java-классы](clojure/examples/3_2_java-objects.clj)

Лекция 4. Разное
 * [Макросы](clojure/examples/4_1_macro.clj)
 * [Макросы для парсеров](clojure/examples/5_4_macro.clj)
 * [Изменяемое состояние](clojure/examples/4_2_mutable-state.clj)
 * [Числа Чёрча](clojure/examples/4_3_church.clj)

Лекция 5. Комбинаторные парсеры
 * [Базовые функции](clojure/examples/5_1_base.clj)
 * [Комбинаторы](clojure/examples/5_2_combinators.clj)
 * [JSON](clojure/examples/5_3_json.clj)


## Домашнее задание 7. Обработка ошибок на JavaScript

1.  Добавьте в предыдущее домашнее задание функцию `parsePrefix(string)`, разбирающую выражения, задаваемые записью вида `(- (* 2 x) 3)`. Если разбираемое выражение некорректно, метод `parsePrefix` должен бросать человеко-читаемое сообщение об ошибке.
2.  Добавьте в предыдущее домашнее задание метод `prefix()`, выдающий выражение в формате, ожидаемом функцией `parsePrefix`.
3.  При выполнение задания следует обратить внимание на:
    *   Применение инкапсуляции.
    *   Выделение общего кода для бинарных операций.
    *   Обработку ошибок.
    *   Минимизацию необходимой памяти.

Модификации
 * *Base*
    * Код должен находиться в файле `javascript-solutions/objectExpression.js`.
    * [Исходный код тестов](javascript/jstest/prefix/ParserTest.java)
        * Запускать c указанием модификации и сложности (`easy` или `hard`).

 * *Prefix*: *Means*. Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `ArithMean` (`arith-mean`) – арифметическое среднее `(arith-mean 1 2 6)` равно 3;
        * `GeomMean` (`geom-mean`) – геометрическое среднее `(geom-mean 1 2 4)` равно 2;
        * `HarmMean` (`harm-mean`) – гармоническое среднее, `(harm-mean 2 3 6)` равно 3;
    * [Исходный код тестов](javascript/jstest/prefix/PrefixTest.java)
 

## Домашнее задание 6. Объектные выражения на JavaScript

1.  Разработайте классы `Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide`, `Negate` для представления выражений с одной переменной.
    1.  Пример описания выражения `2x-3`:
        ```
        let expr = new Subtract(
            new Multiply(
                new Const(2),
                new Variable("x")
            ),
            new Const(3)
        );
        ```                    
        
    2.  Метод `evaluate(x)` должен производить вычисления вида: При вычислении такого выражения вместо каждой переменной подставляется значение `x`, переданное в качестве параметра функции `evaluate` (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число 7.
    3.  Метод `toString()` должен выдавать запись выражения в [обратной польской записи](http://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C). Например, `expr.toString()` должен выдавать `2 x * 3 -`.

2.  При выполнение задания следует обратить внимание на:
    *   Применение инкапсуляции.
    *   Выделение общего кода для операций.

Модификации
 * *Base*
    * Код должен находиться в файле `javascript-solutions/objectExpression.js`.
    * [Исходный код тестов](javascript/jstest/object/ObjectTest.java)
        * Запускать c указанием модификации и сложности (`easy`, `hard` или `bonus`).

 * *AvgMed*. Дополнительно реализовать поддержку:
    * функций:
        * `Avg5` (`avg5`) – арифметическое среднее пяти аргументов, `1 2 3 4 5 avg5` равно 3;
        * `Med3` (`med3`) – медиана трех аргументов, `1 2 -10 med3` равно 1.



## Домашнее задание 5. Функциональные выражения на JavaScript


1.  Разработайте функции `cnst`, `variable`, `add`, `subtract`, `multiply`, `divide`, `negate` для вычисления выражений с одной переменной.
2.  Функции должны позволять производить вычисления вида:
    
    ```
    let expr = subtract(
        multiply(
            cnst(2),
            variable("x")
        ),
        cnst(3)
    );
    println(expr(5));
    ```
                
    
    При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра функции `expr` (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число 7.
3.  Тестовая программа должна вычислять выражение `x2−2x+1`, для `x` от 0 до 10.
4.  При выполнение задания следует обратить внимание на:
    *   Применение функций высшего порядка.
    *   Выделение общего кода для бинарных операций.



Модификации
 * *Базовая*
    * Код должен находиться в файле `javascript-solutions/functionalExpression.js`.
    * [Исходный код тестов](javascript/jstest/functional/ExpressionTest.java)
        * Запускать c аргументом `hard` или `easy`;
 * *Mini* (для тестирования)
    * Не поддерживаются бинарные операции
    * Код находится в файле [functionalMiniExpression.js](javascript/MiniExpression.js).
    * [Исходный код тестов](javascript/jstest/functional/MiniTest.java)
        * Запускать c аргументом `hard` или `easy`;

 * *OneTwo*. Дополнительно реализовать поддержку:
    * переменных: `y`, `z`;
    * констант:
        * `one` – 1;
        * `two` – 2;
    * [Исходный код тестов](javascript/jstest/functional/FunctionalTest.java)
 
Запуск тестов
 * Для запуска тестов используется [GraalJS](https://github.com/graalvm/graaljs)
   (часть проекта [GraalVM](https://www.graalvm.org/), вам не требуется их скачивать отдельно)
 * Для запуска тестов можно использовать скрипты [TestJS.cmd](javascript/TestJS.cmd) и [TestJS.sh](javascript/TestJS.sh)
    * Репозиторий должен быть скачан целиком.
    * Скрипты должны находиться в каталоге `javascript` (их нельзя перемещать, но можно вызывать из других каталогов).
    * В качестве аргументов командной строки указывается полное имя класса теста и модификация, 
      например `jstest.functional.FunctionalExpressionTest hard`.
 * Для самостоятельно запуска из консоли необходимо использовать командную строку вида:
    `java -ea --module-path=<js>/graal --class-path <js> jstest.functional.FunctionalExpressionTest {hard|easy}`, где
    * `-ea` – включение проверок времени исполнения;
    * `--module-path=<js>/graal` путь к модулям Graal (здесь и далее `<js>` путь к каталогу `javascript` этого репозитория);
    * `--class-path <js>` путь к откомпилированным тестам;
    * {`hard`|`easy`} указание тестируемой модификации.
 * При запуске из IDE, обычно не требуется указывать `--class-path`, так как он формируется автоматически.
   Остальные опции все равно необходимо указать.
 * Troubleshooting
    * `Error occurred during initialization of boot layer java.lang.module.FindException: Module org.graalvm.truffle not found, required by jdk.internal.vm.compiler` – неверно указан `--module-path`;
    * `Graal.js not found` – неверно указаны `--module-path`
    * `Error: Could not find or load main class jstest.functional.FunctionalExpressionTest` – неверно указан `--class-path`;
    * `Error: Could not find or load main class <other class>` – неверно указано полное имя класса теста;
    * `Exception in thread "main" java.lang.AssertionError: You should enable assertions by running 'java -ea jstest.functional.FunctionalExpressionTest'` – не указана опция `-ea`;
    * `First argument should be one of: "easy", "hard", found: XXX` – неверно указана сложность;
    * `Exception in thread "main" jstest.EngineException: Script 'functionalExpression.js' not found` – в текущем каталоге отсутствует решение (`functionalExpression.js`)


## Исходный код к лекциям по JavaScript

[Скрипт с примерами](javascript/examples.js)

Запуск примеров
 * [В браузере](javascript/RunJS.html)
 * Из консоли
    * [на Java](javascript/RunJS.java): [RunJS.cmd](javascript/RunJS.cmd), [RunJS.sh](javascript/RunJS.sh)
    * [на node.js](javascript/RunJS.node.js): `node RunJS.node.js`

Лекция 1. Типы и функции
 * [Типы](javascript/examples/1_1_types.js)
 * [Функции](javascript/examples/1_2_functions.js)
 * [Функции высшего порядка](javascript/examples/1_3_functions-hi.js).
   Обратите внимание на реализацию функции `mCurry`.

Лекция 2. Объекты и методы
 * [Объекты](javascript/examples/2_1_objects.js)
 * [Замыкания](javascript/examples/2_2_closures.js)
 * [Модули](javascript/examples/2_3_modules.js)
 * [Пример: стеки](javascript/examples/2_4_stacks.js)

Лекция 3. Другие возможности
 * [Обработка ошибок](javascript/examples/3_1_errors.js)
 * [Чего нет в JS](javascript/examples/3_2_no.js)
 * [Стандартная библиотека](javascript/examples/3_3_builtins.js)
 * [Работа со свойствами](javascript/examples/3_4_properties.js)
 * [Методы и классы](javascript/examples/3_5_classes.js)
 * [JS 6+](javascript/examples/3_6_js6.js)
 * Модули: 
   [объявление](javascript/examples/3_7_js6_module.mjs)
   [использование](javascript/examples/3_7_js6_module_usage.mjs)


## Домашнее задание 4. Вычисление в различных типах

1. Добавьте в программу разбирающую и вычисляющую выражения поддержку различных типов.
   - Первым аргументом командной строки программа должна принимать указание на тип, в котором будут производится вычисления
   - Вторым аргументом командной строки программа должна принимать выражение для вычисления.
   - Реализация не должна содержать непроверяемых преобразований типов.
   - Реализация не должна использовать аннотацию `@SuppressWarnings`.
2. При выполнении задания следует обратить внимание на легкость добавления новых типов и операциий.

Модификации
 * *Базовая*
    * Класс `GenericTabulator` должен реализовывать интерфейс
      [Tabulator](java/expression/generic/Tabulator.java) и
      сроить трехмерную таблицу значений заданного выражения.
        * `mode` – режим вычислений:
           * `i` – вычисления в `int` с проверкой на переполнение;
           * `d` – вычисления в `double` без проверки на переполнение;
           * `bi` – вычисления в `BigInteger`.
        * `expression` – выражение, для которого надо построить таблицу;
        * `x1`, `x2` – минимальное и максимальное значения переменной `x` (включительно)
        * `y1`, `y2`, `z1`, `z2` – аналогично для `y` и `z`.
        * Результат: элемент `result[i][j][k]` должен содержать
          значение выражения для `x = x1 + i`, `y = y1 + j`, `z = z1 + k`.
          Если значение не определено (например, по причине переполнения),
          то соответствующий элемент должен быть равен `null`.
    * [Исходный код тестов](java/expression/generic/GenericTest.java)

 * *Uls* 
    * Дополнительно реализовать поддержку режимов:
        * `u` – вычисления в `int` без проверки на переполнение;
        * `l` – вычисления в `long` без проверки на переполнение;
        * `s` – вычисления в `short` без проверки на переполнение.
    * [Исходный код тестов](java/expression/generic/GenericUlsTest.java)
 

## Домашнее задание 3. Очередь на связном списке
1. Определите интерфейс очереди Queue и опишите его контракт.
2. Реализуйте класс LinkedQueue — очередь на связном списке.
3. Выделите общие части классов LinkedQueue и ArrayQueue в базовый класс AbstractQueue.

Модификации
 * *Базовая*
    * [Исходный код тестов](java/queue/QueueTest.java)
    * [Откомпилированные тесты](artifacts/queue/QueueTest.jar)
 
 * *IndexedToArray*
    * Реализовать методы
        * `get` – получить элемент по индексу, отсчитываемому с головы;
        * `set` – заменить элемент по индексу, отсчитываемому с головы;
        * `toArray`, возвращающий массив, содержащий элементы, 
          лежащие в очереди в порядке от головы к хвосту.
    * [Исходный код тестов](java/queue/QueueIndexedToArrayTest.java)
    * [Откомпилированные тесты](artifacts/queue/QueueIndexedToArrayTest.jar)
 

## Домашнее задание 2. Очередь на массиве
1. Найдите инвариант структуры данных «очередь». Определите функции, которые необходимы для реализации очереди. Найдите их пред- и постусловия, при условии что очередь не содержит null.
2. Реализуйте классы, представляющие циклическую очередь с применением массива.
   - Класс ArrayQueueModule должен реализовывать один экземпляр очереди с использованием переменных класса.
   - Класс ArrayQueueADT должен реализовывать очередь в виде абстрактного типа данных (с явной передачей ссылки на экземпляр очереди).
   - Класс ArrayQueue должен реализовывать очередь в виде класса (с неявной передачей ссылки на экземпляр очереди).
   - Должны быть реализованы следующие функции (процедуры) / методы:
      - enqueue – добавить элемент в очередь;
      - element – первый элемент в очереди;
      - dequeue – удалить и вернуть первый элемент в очереди;
      - size – текущий размер очереди;
      - isEmpty – является ли очередь пустой;
      - clear – удалить все элементы из очереди.
   - Инвариант, пред- и постусловия записываются в исходном коде в виде комментариев.
   - Обратите внимание на инкапсуляцию данных и кода во всех трех реализациях.
3. Напишите тесты к реализованным классам.
Модификации
 * *Базовая*
    * Классы должны находиться в пакете `queue`
    * [Исходный код тестов](java/queue/ArrayQueueTest.java)
    * [Откомпилированные тесты](artifacts/queue/ArrayQueueTest.jar)

 * *Indexed*
    * Реализовать методы
        * `get` – получить элемент по индексу, отсчитываемому с головы
        * `set` – заменить элемент по индексу, отсчитываемому с головы
    * [Исходный код тестов](java/queue/ArrayQueueIndexedTest.java)
    * [Откомпилированные тесты](artifacts/queue/ArrayQueueIndexedTest.jar)

## Домашнее задание 1. Бинарный поиск
1. Реализуйте итеративный и рекурсивный варианты бинарного поиска в массиве.
2. На вход подается целое число x и массив целых чисел a, отсортированный по невозрастанию. Требуется найти минимальное значение индекса i, при котором a[i] <= x.
3. Для функций бинарного поиска и вспомогательных функций должны быть указаны, пред- и постусловия. Для реализаций методов должны быть приведены доказательства соблюдения контрактов в терминах троек Хоара.
4. Интерфейс программы.
    * Имя основного класса — BinarySearch.
    * Первый аргумент командной строки — число x.
    * Последующие аргументы командной строки — элементы массива a.
5. Пример запуска: java BinarySearch 3 5 4 3 2 1. Ожидаемый результат: 2.

Модификации
 * *Базовая*
    * Класс `BinarySearch` должен находиться в пакете `search`
    * [Исходный код тестов](java/search/BinarySearchTest.java)
    * [Откомпилированные тесты](artifacts/search/BinarySearchTest.jar)
 
 * *Min*
    * На вход подается циклический сдвиг 
      отсортированного (строго) по возрастанию массива.
      Требуется найти в нем минимальное значение.
    * Класс должен иметь имя `BinarySearchMin`
    * [Исходный код тестов](java/search/BinarySearchMinTest.java)
    * [Откомпилированные тесты](artifacts/search/BinarySearchMinTest.jar)


Для того, чтобы протестировать базовую модификацию домашнего задания:

 1. Скачайте тесты ([BinarySearchTest.jar](artifacts/search/BinarySearchTest.jar))
 1. Откомпилируйте `BinarySearch.java`
 1. Проверьте, что создался `BinarySearch.class`
 1. В каталоге, в котором находится `search/BinarySearch.class` выполните команду

    ```
       java -jar <путь к BinarySearchTest.jar>
    ```

    Например, если `BinarySearchTest.jar` находится в текущем каталоге, 
    а `BinarySearch.class` в каталоге `search`, выполните команду

    ```
        java -jar BinarySearchTest.jar
    ```
